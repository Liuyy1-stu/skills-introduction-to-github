二叉搜索树
左子树->val < root->val < 右子树->val
中序遍历可以得到升序数组
例：530. 二叉搜索树的最小绝对差
给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值。
差值是一个正数，其数值等于两值之差的绝对值。
示例 1：
输入：root = [4,2,6,1,3]
输出：1
示例 2：
输入：root = [1,0,48,null,null,12,49]
输出：1
解：
void helper(struct TreeNode* root,int* pre,int* ans){
    if(!root) return;
    if(*ans==1) return;
    helper(root->left,pre,ans);                   //中序遍历得到相邻的节点的结果
    if(*pre==-1) *pre = root->val;
    else{
        *ans = fmin(*ans,root->val-*pre);         //更新最小绝对差
        *pre = root->val;
    }
    helper(root->right,pre,ans);
}
int getMinimumDifference(struct TreeNode* root) {
    int ans = INT_MAX,pre = -1;
    helper(root,&pre,&ans);
    return ans;
}
主要思路在于中序遍历得到的相邻节点数值，用递归逐一作比较
